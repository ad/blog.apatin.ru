+++
title = "The uWSGI Spooler"
date = "2017-04-13T10:46:00+03:00"
tags = [
    "техническое",
    "код",
    "uwsgi",
    "spooler"
]
+++

Когда проектируешь масштабируемые системы, где приходится обращаться ко&nbsp;множеству внешних компонент, например, использование стороннего API, отправка почты или конвертация видео, лучшим способом реализации является асинхронная модель с&nbsp;системой очередей, которая является связующим звеном для взаимодействия всех компонент системы&hellip;

Самой популярной системой очередей в&nbsp;Python является Celery, она обладает широким набором возможностей по&nbsp;управлению задачами.

К&nbsp;сожалению, сложные системы на&nbsp;базе Celery сложно поддерживать в&nbsp;работоспособном состоянии и&nbsp;когда что-то идёт не&nbsp;так, то&nbsp;найти проблему бывает весьма не&nbsp;просто. Можете спросить любого девопса об&nbsp;опыте работы с&nbsp;Celery, но&nbsp;будьте готовы услышать не&nbsp;очень приятные слова.

К&nbsp;счастью, есть альтернативное решение и&nbsp;сейчас я&nbsp;расскажу о&nbsp;нём.

<!--more-->


Основным отличием от&nbsp;Celery является то, что не&nbsp;нужно использовать дополнительные компоненты (сам Celery и&nbsp;хранилище, например Redis), таким образом количество точек отказа уменьшается на&nbsp;две. В&nbsp;качестве хранилища задач может использоваться директория, внешняя директория или сетевой пул.

Для управления Python программами мы&nbsp;часто используем uWSGI.

Почему?

Потому что он&nbsp;прост в&nbsp;настройке, очень надежен, очень гибок, выполняет большинство требований.

Кроме обслуживания Python-кода в&nbsp;виде обеспечения непрерывного доступа к&nbsp;web-приложению, в&nbsp;uWSGI входит компонент [Spooler](http://uwsgi-docs.readthedocs.io/en/latest/Spooler.html), который реализует систему очередей.

Spooler имеет некоторые особенности, а&nbsp;документация по&nbsp;нему достаточно скудна.

Использовать uWSGI Spooler просто, как раз-два-три!

Но&nbsp;есть несколько нюансов.

Модуль uwsgi нельзя импортировать из&nbsp;кода, а&nbsp;соответственно тестировать из&nbsp;консоли код не&nbsp;получится, необходимо каждый раз запускать uwsgi воркера, для чего необходимо создать конфиг.

```
[uwsgi]
socket = /var/run/mysite.sock
master = True
processes = 4
project_dir = /home/myuser/mysite
chdir = %(project_dir)
spooler = /var/uwsgi_spools/mysite_spool
spooler-import = path.to.spool.package # (package to&nbsp;import spool file)
spooler-frequency = 10 # Frequency for scanning spool
max-requests = 5000
module = wsgi: application
touch-reload = wsgi.py
```

файл воркера

```
from uwsgidecorators import spool, uwsgi

@spool
def my_func (args):
    print (args)
    # do&nbsp;some job
```

Постановка задачи из&nbsp;вашего кода

```
import uwsgi_spools.mysite_spool as&nbsp;mysite_spool

mysite_spool.my_func.spool(test=True)
```

Как можно убедиться из&nbsp;примера, порог вхождения для использования очень низкий.

Внутри таска доступен один аргумент, который содержит словарь с&nbsp;тремя служебными ключами (имя функции ud_spool_func, имя таска spooler_task_name, статус таска ud_spool_ret) и&nbsp;всеми параметрами, что были переданы при создании таска, в&nbsp;примере это ключ test.

Таск может вернуть три статуса:

- -2 (SPOOL_OK)&nbsp;&mdash; таск выполнен, будет удалён из&nbsp;очереди
- -1 (SPOOL_RETRY)&nbsp;&mdash; что-то пошло не&nbsp;так, таск будет повторно вызван
- 0 (SPOOL_IGNORE)&nbsp;&mdash; игнорировать таск

Особенность, декоратор @spool выполняется единожды (возвращает SPOOL_OK), если функция не&nbsp;упала с&nbsp;исключением. Для для того чтобы управлять жизненным циклом нужно использовать @spoolraw.

Особые ключи (вспомогательные) при создании таска:

- spooler&nbsp;&mdash; абсолютный путь к&nbsp;спулеру, который будет выполнять задачу
- at&nbsp;&mdash; unix time, когда задача должна быть выполнена (правильнее сказать, она не&nbsp;будет выполнена ранее этого значения)
- priority&nbsp;&mdash; указывает на&nbsp;подпапку в&nbsp;папке задач (на&nbsp;такую подпапку можно выделить большее количество воркеров), через --spooler-ordered можно настроить приоритеты
- body&nbsp;&mdash; этот ключ используется для значений более 64 КБ, в&nbsp;задачу будет доступен в&nbsp;сериализованном виде

Кроме декоратора @spool доступен декоратор @timer, который принимает количество секунд в&nbsp;качестве аргумента и&nbsp;позволяет выполнять декорируемую функцию с&nbsp;указанным интервалом.

```
@timer(30)
def my_func (args):
    print (args)
    # do&nbsp;some job every 30 sec
```

Аналогично @timer есть декоратор @spoolforever, который будет повторно запускать выполнение функции (завершение задачи со&nbsp;статусом SPOOL_RETRY).

```
@spoolforever
def my_func (args):
    print (args)
    # do&nbsp;some job and repeat
```

Для настройки воркеров для работы по&nbsp;сети, нужно добавить адрес, по&nbsp;которому он&nbsp;будет доступен в&nbsp;ini-файл

```
socket = 127.0.0.1:10001
```

При создании задачи указывать адрес получателя задачи

```
uwsgi.send_message("127.0.0.1:10001", 17, 0, test=True, 5)
# или
uwsgi.spool (test=True, spooler="127.0.0.1:10001")
```

Таким образом, uWSGI Spooler можно использовать как замену очередям, но&nbsp;если всё&nbsp;же не&nbsp;хватает возможностей или хочется немного сахара, то&nbsp;можно использовать [uwsgi-tasks](https://pypi.python.org/pypi/uwsgi-tasks), реализующий недостающее.
