<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Weblog</title><link>https://blog.apatin.ru/t/uwsgi/</link><description>Личный блог с мыслями и наблюдениями</description><managingEditor>rss@apatin.ru Daniel Apatin</managingEditor><webMaster>rss@apatin.ru Daniel Apatin</webMaster><copyright>Daniel Apatin</copyright><lastBuildDate>Thu, 13 Apr 2017 10:46:00 +0300</lastBuildDate><atom:link href="https://blog.apatin.ru/t/uwsgi/rss.xml" rel="self" type="application/rss+xml"/><item><title>The uWSGI Spooler</title><link>https://blog.apatin.ru/p/uwsgi-spooler/</link><pubDate>Thu, 13 Apr 2017 10:46:00 +0300</pubDate><author>rss@apatin.ru (Daniel Apatin)</author><guid>https://blog.apatin.ru/p/uwsgi-spooler/</guid><description>&lt;p>Когда проектируешь масштабируемые системы, где приходится обращаться ко множеству внешних компонент, например, использование стороннего API, отправка почты или конвертация видео, лучшим способом реализации является асинхронная модель с системой очередей, которая является связующим звеном для взаимодействия всех компонент системы…&lt;/p>
&lt;p>Самой популярной системой очередей в Python является Celery, она обладает широким набором возможностей по управлению задачами.&lt;/p>
&lt;p>К сожалению, сложные системы на базе Celery сложно поддерживать в работоспособном состоянии и когда что-то идёт не так, то найти проблему бывает весьма не просто. Можете спросить любого девопса об опыте работы с Celery, но будьте готовы услышать не очень приятные слова.&lt;/p>
&lt;p>К счастью, есть альтернативное решение и сейчас я расскажу о нём.&lt;/p></description></item></channel></rss>