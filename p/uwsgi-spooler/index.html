<!doctype html><html class=no-js itemscope itemtype=http://schema.org/Product><head><meta charset=utf-8><title>The uWSGI Spooler - Weblog</title><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=og:title content="The uWSGI Spooler - Weblog"><meta property="og:image" content="/static/favicon.png"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="shortcut icon" href=https://blog.apatin.ru/static/favicon.ico type=image/x-icon><link rel=apple-touch-icon href=https://blog.apatin.ru/static/favicon.ico><link rel=stylesheet href=https://blog.apatin.ru/css/main.min.157c034e55c30a3033be80b8464d3375bb6cb8a04d8ee6c6e102071ec1624345.css integrity="sha256-FXwDTlXDCjAzvoC4Rk0zdbtsuKBNjubG4QIHHsFiQ0U=" media=screen><link rel=prev id=link-earlier href=https://blog.apatin.ru/p/postgres_install/><link rel=next id=link-later href=https://blog.apatin.ru/p/osx_terminal_touchid_sudo/></head><body><div class=common><div class=flag><div class=header-content><div class=header-description><div class=title><div class=title-inner><div class=logo-marginal><div class=e2-user-picture-container><img alt=Logo title=Logo src=https://blog.apatin.ru/static/favicon.png></div></div><h1><a href=https://blog.apatin.ru/><span id=e2-blog-title style=font-size:48px>Weblog</span></a></h1></div><div id=e2-blog-description><p>Личный блог с мыслями и наблюдениями</p></div></div></div></div></div><div class=content><div id=e2-note-6 class=e2-note><article><h1 class="e2-published e2-smart-title"><a href=https://blog.apatin.ru/p/uwsgi-spooler/>The uWSGI Spooler</a></h1><div class="e2-note-text e2-text e2-published"><p>Когда проектируешь масштабируемые системы, где приходится обращаться ко множеству внешних компонент, например, использование стороннего API, отправка почты или конвертация видео, лучшим способом реализации является асинхронная модель с системой очередей, которая является связующим звеном для взаимодействия всех компонент системы…</p><p>Самой популярной системой очередей в Python является Celery, она обладает широким набором возможностей по управлению задачами.</p><p>К сожалению, сложные системы на базе Celery сложно поддерживать в работоспособном состоянии и когда что-то идёт не так, то найти проблему бывает весьма не просто. Можете спросить любого девопса об опыте работы с Celery, но будьте готовы услышать не очень приятные слова.</p><p>К счастью, есть альтернативное решение и сейчас я расскажу о нём.</p><p>Основным отличием от Celery является то, что не нужно использовать дополнительные компоненты (сам Celery и хранилище, например Redis), таким образом количество точек отказа уменьшается на две. В качестве хранилища задач может использоваться директория, внешняя директория или сетевой пул.</p><p>Для управления Python программами мы часто используем uWSGI.</p><p>Почему?</p><p>Потому что он прост в настройке, очень надежен, очень гибок, выполняет большинство требований.</p><p>Кроме обслуживания Python-кода в виде обеспечения непрерывного доступа к web-приложению, в uWSGI входит компонент
<a href=http://uwsgi-docs.readthedocs.io/en/latest/Spooler.html target=_blank rel=nofollow>Spooler</a>, который реализует систему очередей.</p><p>Spooler имеет некоторые особенности, а документация по нему достаточно скудна.</p><p>Использовать uWSGI Spooler просто, как раз-два-три!</p><p>Но есть несколько нюансов.</p><p>Модуль uwsgi нельзя импортировать из кода, а соответственно тестировать из консоли код не получится, необходимо каждый раз запускать uwsgi воркера, для чего необходимо создать конфиг.</p><pre><code>[uwsgi]
socket = /var/run/mysite.sock
master = True
processes = 4
project_dir = /home/myuser/mysite
chdir = %(project_dir)
spooler = /var/uwsgi_spools/mysite_spool
spooler-import = path.to.spool.package # (package to&amp;nbsp;import spool file)
spooler-frequency = 10 # Frequency for scanning spool
max-requests = 5000
module = wsgi: application
touch-reload = wsgi.py
</code></pre><p>файл воркера</p><pre><code>from uwsgidecorators import spool, uwsgi

@spool
def my_func (args):
    print (args)
    # do&amp;nbsp;some job
</code></pre><p>Постановка задачи из вашего кода</p><pre><code>import uwsgi_spools.mysite_spool as&amp;nbsp;mysite_spool

mysite_spool.my_func.spool(test=True)
</code></pre><p>Как можно убедиться из примера, порог вхождения для использования очень низкий.</p><p>Внутри таска доступен один аргумент, который содержит словарь с тремя служебными ключами (имя функции ud_spool_func, имя таска spooler_task_name, статус таска ud_spool_ret) и всеми параметрами, что были переданы при создании таска, в примере это ключ test.</p><p>Таск может вернуть три статуса:</p><ul><li>-2 (SPOOL_OK) — таск выполнен, будет удалён из очереди</li><li>-1 (SPOOL_RETRY) — что-то пошло не так, таск будет повторно вызван</li><li>0 (SPOOL_IGNORE) — игнорировать таск</li></ul><p>Особенность, декоратор @spool выполняется единожды (возвращает SPOOL_OK), если функция не упала с исключением. Для для того чтобы управлять жизненным циклом нужно использовать @spoolraw.</p><p>Особые ключи (вспомогательные) при создании таска:</p><ul><li>spooler — абсолютный путь к спулеру, который будет выполнять задачу</li><li>at — unix time, когда задача должна быть выполнена (правильнее сказать, она не будет выполнена ранее этого значения)</li><li>priority — указывает на подпапку в папке задач (на такую подпапку можно выделить большее количество воркеров), через &ndash;spooler-ordered можно настроить приоритеты</li><li>body — этот ключ используется для значений более 64 КБ, в задачу будет доступен в сериализованном виде</li></ul><p>Кроме декоратора @spool доступен декоратор @timer, который принимает количество секунд в качестве аргумента и позволяет выполнять декорируемую функцию с указанным интервалом.</p><pre><code>@timer(30)
def my_func (args):
    print (args)
    # do&amp;nbsp;some job every 30 sec
</code></pre><p>Аналогично @timer есть декоратор @spoolforever, который будет повторно запускать выполнение функции (завершение задачи со статусом SPOOL_RETRY).</p><pre><code>@spoolforever
def my_func (args):
    print (args)
    # do&amp;nbsp;some job and repeat
</code></pre><p>Для настройки воркеров для работы по сети, нужно добавить адрес, по которому он будет доступен в ini-файл</p><pre><code>socket = 127.0.0.1:10001
</code></pre><p>При создании задачи указывать адрес получателя задачи</p><pre><code>uwsgi.send_message(&quot;127.0.0.1:10001&quot;, 17, 0, test=True, 5)
# или
uwsgi.spool (test=True, spooler=&quot;127.0.0.1:10001&quot;)
</code></pre><p>Таким образом, uWSGI Spooler можно использовать как замену очередям, но если всё же не хватает возможностей или хочется немного сахара, то можно использовать
<a href=https://pypi.python.org/pypi/uwsgi-tasks target=_blank rel=nofollow>uwsgi-tasks</a>, реализующий недостающее.</p></div></article><div class=e2-note-tags><span class=e2-timestamp>13.04.2017</span> &nbsp;
<a href=https://blog.apatin.ru/t/%D1%82%D0%B5%D1%85%D0%BD%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5 class=e2-tag>техническое</a> &nbsp;
<a href=https://blog.apatin.ru/t/%D0%BA%D0%BE%D0%B4 class=e2-tag>код</a> &nbsp;
<a href=https://blog.apatin.ru/t/uwsgi class=e2-tag>uwsgi</a> &nbsp;
<a href=https://blog.apatin.ru/t/spooler class=e2-tag>spooler</a> &nbsp;</div></div><div class=e2-pages><a href=https://blog.apatin.ru/p/postgres_install/>Ранее</a>
<span class=e2-keyboard-shortcut>↓</span>
<span class=e2-keyboard-shortcut>⌥</span>
<span class=e2-keyboard-shortcut>↑</span>
<a href=https://blog.apatin.ru/p/osx_terminal_touchid_sudo/>Позднее</a></div><h4 class=page-header>Рекомендуемые посты:</h4><div id=e2-note-6><a href=https://blog.apatin.ru/p/to-gh-pages/><h5 class="e2-published e2-smart-title" style=font-size:18px>Переезд на Github Pages</h5></a><div class=e2-note-tags><span class=e2-timestamp>31.01.2021</span></div></div><br><div id=e2-note-6><a href=https://blog.apatin.ru/p/how-cloudflare-protect-email/><h5 class="e2-published e2-smart-title" style=font-size:18px>Как Cloudflare защищает email</h5></a><div class=e2-note-tags><span class=e2-timestamp>26.04.2020</span></div></div><br><div id=disqus_thread></div><script>(function(){var d=document,s=d.createElement('script');s.src='https://weblog-5.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=footer>&copy;
<span id=e2-blog-author>Daniel Apatin</span>,
2008—2021
<a href=https://blog.apatin.ru/rss.xml type=application/rss+xml target=_blank class=e2-rss-button>RSS</a>
<a class=e2-rss-button href=https://blog.apatin.ru/tags/>Теги</a></div></div><script type=text/javascript>(function(d,w,c){(w[c]=w[c]||[]).push(function(){try{w.yaCounter21943429=new Ya.Metrika({id:21943429,clickmap:false,trackLinks:true,accurateTrackBounce:true});}catch(e){}});var n=d.getElementsByTagName("script")[0],s=d.createElement("script"),f=function(){n.parentNode.insertBefore(s,n);};s.type="text/javascript";s.async=true;s.src="https://mc.yandex.ru/metrika/watch.js";if(w.opera=="[object Opera]"){d.addEventListener("DOMContentLoaded",f,false);}else{f();}})(document,window,"yandex_metrika_callbacks");</script><noscript><div><img src=https://mc.yandex.ru/watch/21943429 style=position:absolute;left:-9999px alt></div></noscript><script type=text/javascript>document.addEventListener("DOMContentLoaded",function(){var lazyImages=[].slice.call(document.querySelectorAll("img.lazy"));if("IntersectionObserver"in window){let lazyImageObserver=new IntersectionObserver(function(entries,observer){entries.forEach(function(entry){if(entry.isIntersecting){let lazyImage=entry.target;lazyImage.src=lazyImage.dataset.src;lazyImage.classList.remove("lazy");lazyImageObserver.unobserve(lazyImage);}});});lazyImages.forEach(function(lazyImage){lazyImageObserver.observe(lazyImage);});}else{}});Array.from(document.getElementsByClassName("__email__")).forEach(function(l,index,array){var a=l.getAttribute("data-class");if(a){var s='';var r=parseInt(a.substr(0,2),16);for(var j=2;a.length-j;j+=2){var c=parseInt(a.substr(j,2),16)^r;s+=String.fromCharCode(c);}
l.parentNode.href="mailto:"+s;l.parentNode.innerText=s;}});</script></body><ok></html>